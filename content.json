{"meta":{"title":"云神","subtitle":"夏木春休","description":"个人博客","author":"yunshen","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-08-31T07:40:22.000Z","updated":"2022-08-31T07:46:04.797Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"photos","date":"2022-08-31T08:34:58.467Z","updated":"2022-08-31T08:34:58.467Z","comments":false,"path":"photos/index.html","permalink":"http://example.com/photos/index.html","excerpt":"","text":""}],"posts":[{"title":"java09 集合框架","slug":"java基础/java09","date":"2022-09-10T11:11:36.000Z","updated":"2022-09-10T11:12:37.935Z","comments":true,"path":"2022/09/10/java基础/java09/","link":"","permalink":"http://example.com/2022/09/10/java%E5%9F%BA%E7%A1%80/java09/","excerpt":"集合类是Java数据结构的实现 Java集合类允许以各种方式将元素分组，并定义了各种使用这些元素更容易操作的方法 Java集合可分为Collection和Map两种体系","text":"集合类是Java数据结构的实现 Java集合类允许以各种方式将元素分组，并定义了各种使用这些元素更容易操作的方法 Java集合可分为Collection和Map两种体系 Collection接口：Set:元素无序、不可重复的集合；List:元素有序，可重复的集合 - 动态数组 Map接口：具有映射关系“key-value对”的集合 List接口：扩展了Collection接口，具有顺序的集合，元素可以通过其整型下标访问，可以包含重复元素；方法分类：定位方法：get()、set()、add()、remove()、addAll(); 搜索方法：indexOf()和lastIndexOf()[搜索方法不常用] ListIterator方法：listIterator()和subList() Set接口：是Collection的子接口，set接口没有提供额外的方法 Set集合不允许包含相同的元素，如果试把两个相同的元素加入同一个set集合中，则添加操作失败 Set实现类：HashSet HashSet是Set接口的典型实现，大多数时候使用Set集合时都使用这个实现类 HashSet具有以下特点：不能保证元素的排序顺序；HashSet不是线程安全的；集合元素可以是null 遍历：把一个数组的所有元素全部取出来 Map接口：用于保存具有映射关系的数据：Key-Value 关键字唯一，将键映射至值得对象，每个键最多都只能映射至一个值； 基本操作：put()、get()、remove()、containsKey()、containsValue()、size()和isEmpty() 批操作：putAll()和clear() 集合视图:keySet()、values()和entrySet() 键值对：k-v key-value 基本数据类型里面不能存null，如果没有赋值，默认是0； Map接口常用的实现类：HashMap、TreeMap和Properties HashMap是Map接口使用频率最高的实现类 允许使用null键和null值，与HashSet一样，不保证映射的顺序","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"html02 css属性","slug":"前端基础/html02","date":"2022-09-10T11:04:35.000Z","updated":"2022-09-10T11:09:05.036Z","comments":true,"path":"2022/09/10/前端基础/html02/","link":"","permalink":"http://example.com/2022/09/10/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/html02/","excerpt":"","text":"","categories":[],"tags":[{"name":"前端基础","slug":"前端基础","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}]},{"title":"java08 异常及捕获异常1","slug":"java基础/java08","date":"2022-09-10T10:20:58.000Z","updated":"2022-09-10T10:45:49.185Z","comments":true,"path":"2022/09/10/java基础/java08/","link":"","permalink":"http://example.com/2022/09/10/java%E5%9F%BA%E7%A1%80/java08/","excerpt":"异常：在Java语音中，将程序执行中发生的不正常情况称为“异常”（开发过程中的语法错误和逻辑错误不是异常） Java程序在执行过程中所发生的异常事件可分为两类： Error:Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。一般不编写针对性的代码进行处理；","text":"异常：在Java语音中，将程序执行中发生的不正常情况称为“异常”（开发过程中的语法错误和逻辑错误不是异常） Java程序在执行过程中所发生的异常事件可分为两类： Error:Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。一般不编写针对性的代码进行处理； Exception:其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理，列如：1空指针访问；2试图读取不存在的文件；3网络连接中断 对于这些错误，一般有两种解决方法：1遇到错误就终止程序的运行；2由程序员在编写程序时，就考虑到错误的检测、错误消息的提示及错误的处理； 捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生，比如：除数为0，数组下标越界等 分类：编译时异常和运行时异常 运行异常：指的是编译器不要求强制处理的异常。一般指编程时的逻辑错误，是程序员应该积极避免其出现的异常 java.lang.RuntimeException类及它的子类都是运行时异常 对于这类异常，可以不做处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响； 编译时异常：是指编译器要求必须处理的异常。即程序在运行时由于外界因素造成的一般性异常。编译器要求Java程序必须捕获或声明所有编译异常 对于这类异常，如果程序不处理，可能带来意想不到的结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static void e1()&#123; List l = new ArrayList(); l.add(&quot;aa&quot;); l.add(123); for (int i = 0; i &lt; l.size(); i++)&#123; //异常处理 String s = &quot;&quot;; try &#123; //类型转换异常 s = (String)l.get(i);//把认为可能出现异常的代码放入try&#123;&#125;里面 &#125;catch (Exception e)&#123;//定义一个Exception存到e System.out.println(s + &quot;出现异常&quot;);//出现异常运行catch&#123;&#125;里面的代码 &#125; System.out.println(s); &#125; System.out.println(&quot;==================&quot;);&#125;public static void e2()&#123; //空指针异常 User u = null; u.setName(&quot;123&quot;);&#125;public static void e3()&#123; //除数为0异常 int a = 1; int b = 0; try &#123; System.out.println(a / b); &#125;catch (Exception e)&#123; System.out.println(&quot;出现问题&quot;); &#125; System.out.println(&quot;============&quot;);&#125;public static void e4()&#123; //数组越界异常 int[] arr = &#123;1,2,3&#125;;//下标只有0,1,2 System.out.println(arr[3]);//这里是3&#125; 捕获异常（1） try： 捕获异常第一步是用try{…}语句块选定捕获异常的范围，将可能出现异常的代码放在try语句块中 catch(Exceptiontype e){…} 在catch语句块中对异常对象进行处理的代码。每个try语句块可以伴随一个或多个catch语句，用于处理可能产生不同类型的异常对象 12345678910111213141516171819public static void e5()&#123; try &#123; User u = null; u.setName(&quot;123&quot;); System.out.println(1 / 0); &#125;catch (NullPointerException e1)&#123; System.out.println(&quot;空指针异常&quot;); &#125;catch (ArithmeticException e2)&#123; System.out.println(&quot;除数为0&quot;); &#125;finally &#123;//这里面的代码保证运行 //无论try&#123;&#125;里面是否有异常什么情况都会运行 System.out.println(&quot;finally&quot;); &#125; System.out.println(&quot;======&quot;);&#125; 捕获异常（2）： 与其他对象一样，可以访问一个异常对象的成员变量或调用它的方法： getMessage()获取异常信息，返回字符串 printStackTrace()获取异常类名和异常信息，以及异常出现在程序中的位置，返回值void","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"html01 HTML基本指令","slug":"前端基础/html01","date":"2022-09-10T10:20:22.000Z","updated":"2022-09-10T11:03:34.737Z","comments":true,"path":"2022/09/10/前端基础/html01/","link":"","permalink":"http://example.com/2022/09/10/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/html01/","excerpt":"1234567891011&lt;!--...--&gt; 定义注释&lt;!DOCTYPE&gt; 定义文档类型&lt;a&gt; 定义超文本链接&lt;abbr&gt; 定义缩写&lt;acronym&gt; 定义只取首字母的缩写，不支持HTML5&lt;address&gt; 定义文档作者或拥有者的联系信息","text":"1234567891011&lt;!--...--&gt; 定义注释&lt;!DOCTYPE&gt; 定义文档类型&lt;a&gt; 定义超文本链接&lt;abbr&gt; 定义缩写&lt;acronym&gt; 定义只取首字母的缩写，不支持HTML5&lt;address&gt; 定义文档作者或拥有者的联系信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225&lt;applet&gt; HTML5中不赞成使用。定义嵌入的 applet。&lt;area&gt; 定义图像映射内部的区域&lt;article&gt; 定义一个文章区域&lt;aside&gt; 定义页面的侧边栏内容&lt;audio&gt; 定义音频内容&lt;b&gt; 定义文本粗体&lt;base&gt; 定义页面中所有链接的默认地址或默认目标&lt;basefont&gt; HTML5不支持，不赞成使用。定义页面中文本的默认字体、颜色或尺寸&lt;bdi&gt;New 允许您设置一段文本，使其脱离其父元素的文本方向设置&lt;bdo&gt; 定义文字方向&lt;big&gt; 定义大号文本，HTML5不支持&lt;blockquote&gt; 定义长的引用&lt;body&gt; 定义文档的主体&lt;br&gt; 定义换行&lt;button&gt; 定义一个点击按钮&lt;canvas&gt;New 定义图形，比如图表和其他图像,标签只是图形容器，您必须使用脚本来绘制图形&lt;caption&gt; 定义表格标题&lt;center&gt; HTML5不支持，不赞成使用。定义居中文本。&lt;cite&gt; 定义引用(citation)&lt;code&gt; 定义计算机代码文本&lt;col&gt; 定义表格中一个或多个列的属性值&lt;colgroup&gt; 定义表格中供格式化的列组&lt;command&gt;New 定义命令按钮，比如单选按钮、复选框或按钮&lt;datalist&gt;New 定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。&lt;dd&gt; 定义定义列表中项目的描述&lt;del&gt; 定义被删除文本&lt;details&gt;New 用于描述文档或文档某个部分的细节&lt;dfn&gt; 定义定义项目&lt;dialog&gt;New 定义对话框，比如提示框&lt;dir&gt; HTML5不支持，不赞成使用。定义目录列表。&lt;div&gt; 定义文档中的节&lt;dl&gt; 定义列表详情&lt;dt&gt; 定义列表中的项目&lt;em&gt; 定义强调文本&lt;embed&gt; 定义嵌入的内容，比如插件。&lt;fieldset&gt; 定义围绕表单中元素的边框&lt;figcaption&gt; 定义&lt;figure&gt; 元素的标题&lt;figure&gt;New 规定独立的流内容（图像、图表、照片、代码等等）。&lt;font&gt; HTML5不支持，不赞成使用。定义文字的字体、尺寸和颜色。&lt;footer&gt; 定义 section 或 document 的页脚。&lt;form&gt; 定义了HTML文档的表单&lt;frame&gt; 定义框架集的窗口或框架&lt;frameset&gt; 定义框架集&lt;h1&gt; to &lt;h6&gt; 定义 HTML 标题&lt;head&gt; 定义关于文档的信息&lt;header&gt; 定义了文档的头部区域&lt;hr&gt; 定义水平线&lt;html&gt; 定义 HTML 文档&lt;i&gt; 定义斜体字&lt;iframe&gt; 定义内联框架&lt;img&gt; 定义图像&lt;input&gt; 定义输入控件&lt;ins&gt; 定义被插入文本&lt;kbd&gt; 定义键盘文本&lt;keygen&gt; 规定用于表单的密钥对生成器字段。&lt;label&gt; 定义 input 元素的标注&lt;legend&gt; 定义 fieldset 元素的标题。&lt;li&gt; 定义列表的项目&lt;link&gt; 定义文档与外部资源的关系&lt;main&gt; 定义文档的主体部分。&lt;map&gt; 定义图像映射&lt;mark&gt; 定义带有记号的文本。请在需要突出显示文本时使用 &lt;em&gt; 标签。&lt;menu&gt; 不赞成使用。定义菜单列表。&lt;meta&gt; 定义关于 HTML 文档的元信息。&lt;meter&gt; 定义度量衡。仅用于已知最大和最小值的度量。&lt;nav&gt; 定义导航链接的部分&lt;noframes&gt; 定义针对不支持框架的用户的替代内容。HTML5不支持&lt;noscript&gt; 定义针对不支持客户端脚本的用户的替代内容。&lt;object&gt; 定义内嵌对象&lt;ol&gt; 定义有序列表。&lt;optgroup&gt; 定义选择列表中相关选项的组合。&lt;option&gt; 定义选择列表中的选项。&lt;output&gt; 定义不同类型的输出，比如脚本的输出。&lt;p&gt; 定义段落。&lt;param&gt; 定义对象的参数。&lt;pre&gt; 定义预格式文本。&lt;progress&gt; 定义运行中的进度（进程）。&lt;q&gt; 定义短的引用。&lt;rp&gt;New &lt;rp&gt; 标签在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容。&lt;rt&gt;New &lt;rt&gt; 标签定义字符（中文注音或字符）的解释或发音。&lt;ruby&gt;New &lt;ruby&gt; 标签定义 ruby 注释（中文注音或字符）。&lt;s&gt; 不赞成使用。定义加删除线的文本。&lt;samp&gt; 定义计算机代码样本。&lt;script&gt; 定义客户端脚本。&lt;section&gt; &lt;section&gt; 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。&lt;select&gt; 定义选择列表（下拉列表）。&lt;small&gt; 定义小号文本。&lt;source&gt;New &lt;source&gt; 标签为媒介元素（比如 &lt;video&gt; 和 &lt;audio&gt;）定义媒介资源。&lt;span&gt; 定义文档中的节。&lt;strike&gt; HTML5不支持，不赞成使用。定义加删除线文本。&lt;strong&gt; 定义强调文本。&lt;style&gt; 定义文档的样式信息。&lt;sub&gt; 定义下标文本。&lt;summary&gt; 标签包含 details 元素的标题，&quot;details&quot; 元素用于描述有关文档或文档片段的详细信息。&lt;sup&gt; 定义上标文本。&lt;table&gt; 定义表格。&lt;tbody&gt; 定义表格中的主体内容。&lt;td&gt; 定义表格中的单元。&lt;textarea&gt; 定义多行的文本输入控件。&lt;tfoot&gt; 定义表格中的表注内容（脚注）。&lt;th&gt; 定义表格中的表头单元格。&lt;thead&gt; 定义表格中的表头内容。&lt;time&gt; 定义日期或时间，或者两者。&lt;template&gt; 定义在页面加载时隐藏的一些内容。&lt;title&gt; 定义文档的标题。&lt;tr&gt; 定义表格中的行。&lt;track&gt; 标签为诸如 video 元素之类的媒介规定外部文本轨道。&lt;tt&gt; 定义打字机文本。&lt;u&gt; 不赞成使用。定义下划线文本。&lt;ul&gt; 定义无序列表。&lt;var&gt; 定义文本的变量部分。&lt;video&gt; 标签定义视频，比如电影片段或其他视频流。&lt;wbr&gt; 规定在文本中的何处适合添加换行符。","categories":[],"tags":[{"name":"前端基础","slug":"前端基础","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}]},{"title":"java07 java泛型","slug":"java基础/java07","date":"2022-09-10T08:02:37.000Z","updated":"2022-09-10T08:21:50.467Z","comments":true,"path":"2022/09/10/java基础/java07/","link":"","permalink":"http://example.com/2022/09/10/java%E5%9F%BA%E7%A1%80/java07/","excerpt":"Java笔记5（泛型） Map实现类：Properites properties类是Hashtable的子类，该对象用于处理属性文件","text":"Java笔记5（泛型） Map实现类：Properites properties类是Hashtable的子类，该对象用于处理属性文件 Map实现类：Properites properties类是Hashtable的子类，该对象用于处理属性文件 由于属性文件里的key、value都是字符串类型，所以Properites里的key和value都是字符串类型 存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法 Iterator接口 Iterator对象称为迭代器，主要用于遍历Collection集合中的元素 所有实现了Collection接口的集合类都有一个iterator()方法，用于返回一个实现了Iterator接口的对象 Iterator仅用于遍历集合，Iterator本身并不提供承装对象的能力，如果需要创建Iterator对象，则必须有一个被迭代的集合 泛型： JDK1.5新加入的，解决数据类型的安全性问题，其中主要原理是在类声明时通过一个标识表示类中某个属性的类型或者某个方法的返回值及参数类型，这样在类声明或实例化时只要指定好需要的具体的类型即可 泛型好处： 1可读性，可以判断集合中的内容类型； 2类型检查，避免插入非法类型； 3获取数据时不在需要强制类型转换； 4类型安全，通过知道使用泛型定义的变量的类型限制，编译器可以更有效地提高Java程序的类型安全； 5提高性能 泛型接口： 泛型接口与泛型类的定义及使用基本相同，泛型接口常被用在各种类的生产器中： 定义一个泛型接口： public interface Generator{ public T next(); } 泛型方法： &#x2F;&#x2F;不借助泛型类来写泛型方法 public class Demo04 { public T goGo(T str) { return str; } public &lt;K,V&gt; K gogo(K str,V aa) { ​ return str; }","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"java06 Java继承","slug":"java基础/java06","date":"2022-09-03T15:44:24.000Z","updated":"2022-09-03T15:48:39.593Z","comments":true,"path":"2022/09/03/java基础/java06/","link":"","permalink":"http://example.com/2022/09/03/java%E5%9F%BA%E7%A1%80/java06/","excerpt":"继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。","text":"继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 继承的作用：通过继承可以快速创建新的类，实现代码的重用，提高程序的可维护性，节省大量创建新类的时间，提高开发效率和开发质量。 子类不能选择性继承父类； Java不支持多重继承，但一个类可以实现多个接口，从而克服单继承的缺点； 构造方法不会被子类继承，但可以从子类中调用父类的构造方法。 继承的优点继承过来的字段和方法，可以像任何其他字段和方法一样被直接使用；在子类中可以声明一个与父类中同名的新字段或静态方法，从而“隐藏”父类中的字段或方法；可以在子类中声明一个在父类中没有的新字段和方法；可以在子类中编写一个父类当中具有相同名的新实例方法，这称为“方法重写”或“方法覆盖”；可以在子类中编写一个调用父类构造方法的子类构造方法，既可以隐式地实现，也可以通过使用关键字super来实现。 package com.yunshen.demo; public class Animal {&#x2F;&#x2F;父类 放动物共有的属性 //属性 private String name; private int age; private int hp; private int sex; //构造方法 public Animal() &#123; // TODO Auto-generated constructor stub System.out.println(&quot;这是Animal的无参构造&quot;); &#125; public Animal(String name, int age, int hp, int sex) &#123; super(); this.name = name; this.age = age; this.hp = hp; this.sex = sex; &#125; //成员方法 public void eat() &#123; System.out.println(&quot;动物吃的方法&quot;); &#125; public void sleep() &#123; System.out.println(&quot;动物睡的方法&quot;); &#125; public void run() &#123; System.out.println(&quot;动物跑的方法&quot;); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getHp() &#123; return hp; &#125; public void setHp(int hp) &#123; this.hp = hp; &#125; public int getSex() &#123; return sex; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125; @Override public String toString() &#123; return &quot;Animal [name=&quot; + name + &quot;, age=&quot; + age + &quot;, hp=&quot; + hp + &quot;, sex=&quot; + sex + &quot;]&quot;; &#125; } package com.yunshen.demo; public class Cat extends Animal{&#x2F;&#x2F;Cat 继承 Animal public Cat () &#123; System.out.println(&quot;Cat的构造方法&quot;); &#125; public void eat() &#123; System.out.println(&quot;猫吃老鼠&quot;); &#125; } package com.yunshen.demo; public class Snake extends Animal { private int sp; public Snake() &#123; // TODO Auto-generated constructor stub &#125; public Snake(String name, int age, int hp, int sex) &#123; // TODO Auto-generated constructor stub &#125; public void px() &#123; System.out.println(&quot;爬行&quot;); &#125; public int getSp() &#123; return sp; &#125; public void setSp(int sp) &#123; this.sp = sp; &#125; } package com.yunshen.demo; public class Test { public static void main(String[] args) &#123; &#x2F;&#x2F; Animal an &#x3D; new Animal();&#x2F;&#x2F; an.setHp(1000);&#x2F;&#x2F; an.eat(); System.out.println(&quot;------Cat-----&quot;); /* * * 构造子类对象的时候，父类的构造方法会被执行 * 如果子类也有父类一样的方法，就会使用子类自己的方法 * */ Cat cat = new Cat(); cat.eat(); cat.setName(&quot;加菲&quot;); System.out.println(cat.getName()); System.out.println(&quot;------Snake----&quot;); /* * * 继承父类的同时，子类对象本身也可以拥有自己的属性和方法 * */ Snake s = new Snake(); s.eat(); s.px();//自己的方法 s.getSp();//自己独有的属性 s.setHp(500); System.out.println(s.getHp()); /* * 总结： * 属性： * 如果父类有，子类没有，那么子类直接继承父类的属性，如果子类有，那么就用自己的属性 * * 方法： * 如果父类有方法，子类没有，那就用父类的方法，如果子类也有这个方法，，那么子类就执行自己的方法 * * 方法的重写： * 子类和父类的方法具有相同的名字、参数、类型及个数还有返回值也相同 * */ &#125; } package com.yunshen.demo; public class Test2 { public static void main(String[] args) &#123; Animal animal = new Animal(); animal.setName(&quot;动物&quot;); Animal an = new Cat(); an.eat(); Cat cat = (Cat) an;//(强制转换)向下转型，父类转成子类 cat.eat(); &#125; }","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"java05 java快速生成无参与有参构造，快速构建get和set","slug":"java基础/java05","date":"2022-08-31T14:00:42.000Z","updated":"2022-08-31T14:04:31.876Z","comments":true,"path":"2022/08/31/java基础/java05/","link":"","permalink":"http://example.com/2022/08/31/java%E5%9F%BA%E7%A1%80/java05/","excerpt":"Tostring的使用： 在需要使用tostring的实体类里面的空白处右键-找到source-找到Generate toString-选择所以属性，点击 Gennerate即可","text":"Tostring的使用： 在需要使用tostring的实体类里面的空白处右键-找到source-找到Generate toString-选择所以属性，点击 Gennerate即可 快速生成无参与有参构造 无参：右键–source–generate constructors form Superclass–点击generated 有参：右键–source–generate constructor using Field–点击generated 一般实体类的属性都是私有化的，提供公有的方法进行访问，方法快速构建如下： 快速构建get和set：空白处–右键–source–generated getter and setter–选择让外部类访问的属性–点击generated","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"java04 java方法/函数封装","slug":"java基础/java04","date":"2022-08-31T13:29:21.000Z","updated":"2022-08-31T13:39:54.702Z","comments":true,"path":"2022/08/31/java基础/java04/","link":"","permalink":"http://example.com/2022/08/31/java%E5%9F%BA%E7%A1%80/java04/","excerpt":"方法&#x2F;函数的封装格式： 概念：方法可以把相对独立的某个功能抽象出来，使之成为程序中的一个独立实体，可以在同一程序或其他程序中多次重复使用 类型：1、无参无返回值","text":"方法&#x2F;函数的封装格式： 概念：方法可以把相对独立的某个功能抽象出来，使之成为程序中的一个独立实体，可以在同一程序或其他程序中多次重复使用 类型：1、无参无返回值 有参无返回值有参有返回无参有返回值 修饰符 返回值 方法名（参数的类型 参数的变量名）{ 方法体 } 修饰符：public 修饰，一般方法都是用public 返回值：可以是基础数据类型或者复合数据类型，如果没有返回值用void表示 如果有 方法体中结束的时候用return返回对应内容 参数：可以有或者没有，如果有，格式为（参数类型 参数的变量名） 使用main调用，main方法对应类里面的方法的时候，只能调用也有static修饰的方法 调用： 在同一个类里面调用方法 gameHllo()等同与 这个类 this.gameHello() 如果调用其他类里面的方法 先实例化这个类 类的变量名.方法名 package com.yunshen.home; public class HomeUtil { //第一题 public void showLove(int item) &#123;//item为形参 for (int i = 0; i &lt; item; i++) &#123; System.out.println(&quot;云神&quot;); &#125; &#125; //第二题 public void ps(String str) &#123;//形参，只有在后面的括号中可以使用,在调用方法的时候，传入的是实参 System.out.println(str); &#125; ​ &#x2F;&#x2F;第三题 public void showIntArr(int [] arr) { System.out.print(“arr中的值”); for (int i &#x3D; 0; i &lt; arr.length; i++) { System.out.print(arr[i] + “ “); } } //第四题 public void showCharArr2(char[][] chr) &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; chr.length; i++) &#123; for (int j = 0; j &lt; chr.length; j++) &#123; System.out.print(chr[i][j] + &quot; &quot;); &#125; System.out.println(); &#125; &#125; ​ ​ ​ &#x2F;&#x2F;第7题 public int findMax(int[] arr) { &#x2F;&#x2F; TODO Auto-generated method stub int max = 0; for (int i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; return max; &#125; ​ &#x2F;&#x2F;第9题 public int[] addNum(int num, int[] arr) { &#x2F;&#x2F; TODO Auto-generated method stub //获取新数组 int [] newArr = new int [arr.length + 1]; for (int i = 0; i &lt; arr.length; i++) &#123; newArr[i] = arr[i];//把旧数组放到新数组 &#125; newArr[newArr.length - 1] = num;//newArr.length - 1是数组的最后一位数 return newArr; &#125; package com.yunshen.home; import java.util.Scanner; &#x2F;* * 在main方法中根据键盘插入一个1-3000之间的数字n，另外写一个方法showLove，传入这个n，循环n次“云神” *&#x2F; public class Home1 { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(&quot;输入一个1-3000之间的数字&quot;); int num = scanner.nextInt(); if (num &gt; 0 &amp;&amp; num &lt;3000) &#123; /* for (int i = 0; i &lt; num; i++) &#123; System.out.println(&quot;云神&quot;); &#125; */ //实例化工具 HomeUtil hu = new HomeUtil(); hu.showLove(num); &#125;else &#123; System.out.println(&quot;输入有误&quot;); &#125; ​ ​ ​ ​ } } package com.yunshen.home; import java.util.Scanner;&#x2F;* * 在main方法中定义一个字符串，另外写一个方法ps，传入这个字符串，此方法专门负责将传入的字符串打印出来 *&#x2F; public class Home2 { public static void main(String[] args) &#123; String str = &quot;我是个字符串&quot;; // 实例化工具 HomeUtil hu = new HomeUtil(); hu.ps(str); &#125; } package com.yunshen.home; &#x2F;* * 在main方法中定义一个数组，写一个方法showInterArr,专门用来遍历int类型的一维数组 *&#x2F; public class Home3 { public static void main(String[] args) { int [] arr = &#123;1,22,333,44,5&#125;; HomeUtil hu = new HomeUtil(); hu.showIntArr(arr); ​ } } package com.yunshen.home; &#x2F;* * 写一个方法showCharArr2,专门用来遍历char类型的二维数组 *&#x2F;public class Home4 {public static void main(String[] args) {char [][] chr = &#123; &#123;&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;&#125;, &#123;&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;&#125;, &#123;&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;&#125;, &#123;&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;&#125;, &#123;&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;&#125; &#125;; HomeUtil hu = new HomeUtil(); hu.showCharArr2(chr); ​ } } package com.yunshen.home;&#x2F;* * 7.在main方法中有一个int类型的一维数组，写一个方法findMax,用于获取数组中的最大值，调用方法之后将返回的最大值赋值给一个变量a，把a打印出来 *&#x2F; public class Home5 { public static void main(String[] args) { int [] arr = &#123;1,-43,23,345,34&#125;; ​ HomeUtil hu &#x3D; new HomeUtil(); int a &#x3D; hu.findMax(arr); System.out.println(a); &#125; } package com.yunshen.home; import java.util.Scanner; &#x2F;* * 9.在main方法中定义一个int类型的一维数组，根据键盘输入一个数字，写一个方法addNum，传入这个数字和数组，把这个 数字加到这个数组的末尾，之后在main方法中调用addNum的方法把返回的数组赋值给原来的数组，并遍历原来的数组 *&#x2F; public class Home9 { public static void main(String[] args) { int [] arr = &#123;1,22,33,44,555,6&#125;; Scanner scanner = new Scanner(System.in); System.out.println(&quot;输入一个数字:&quot;); HomeUtil hu = new HomeUtil(); int num = scanner.nextInt(); arr = hu.addNum(num,arr); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot; &quot;); &#125; } } }","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"java03 求一个数组的最大值","slug":"java基础/java03","date":"2022-08-31T13:22:44.000Z","updated":"2022-08-31T13:23:19.040Z","comments":true,"path":"2022/08/31/java基础/java03/","link":"","permalink":"http://example.com/2022/08/31/java%E5%9F%BA%E7%A1%80/java03/","excerpt":"","text":"package com.yunshen.demo; public class Test2 { public static void main(String[] args) { //静态初始化 int [] array = &#123;1,2,3,4,5,6,7,8,9,10&#125;; ​​ &#x2F;&#x2F;遍历数组​ for (int i &#x3D; 0; i &lt; array.length; i++) {​ System.out.println(array[i] + “ “);​ }​​ &#x2F;&#x2F;求和​ int sum &#x3D; 0;​ for (int i &#x3D; 0; i &lt; array.length; i++) {​ sum &#x3D; array[i] + sum;&#x2F;&#x2F;sum +&#x3D; array[i];​ }​ System.out.println(“和为：” +sum);​ System.out.println(&quot;-----------&quot;); //求数组的最大值 int [] array2 = &#123;-10,-5,2,20,5,100,13,14,10&#125;; int max = array2[0];//假设第一个值是最大的，然后逐一往后比 for (int i = 0; i &lt; array2.length; i++) &#123; if (max &lt; array2[i]) &#123; max = array2[i]; &#125; &#125; System.out.println(max); ​​ } }","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"java02 输出一个九九乘法表","slug":"java基础/java02","date":"2022-08-31T13:20:31.000Z","updated":"2022-08-31T13:21:11.490Z","comments":true,"path":"2022/08/31/java基础/java02/","link":"","permalink":"http://example.com/2022/08/31/java%E5%9F%BA%E7%A1%80/java02/","excerpt":"","text":"package com.yunshen.home; public class Shape1 { public static void main(String[] args) { for (int i = 1; i &lt; 10; i++) &#123; for (int j = 1; j &lt; i+1; j++) &#123; System.out.print(i + &quot;*&quot; +j + &quot;=&quot; + i * j + &quot; &quot;); &#125; System.out.println(&quot; &quot;); &#125; &#125; }","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"java01 random随机数","slug":"java基础/java01","date":"2022-08-31T13:17:30.000Z","updated":"2022-08-31T13:19:06.313Z","comments":true,"path":"2022/08/31/java基础/java01/","link":"","permalink":"http://example.com/2022/08/31/java%E5%9F%BA%E7%A1%80/java01/","excerpt":"","text":"如果要生成一个0-9之间的随机数: Random ran &#x3D; new Random(); &#x2F;&#x2F;先实例化random对象 int num &#x3D; ran.nextInt(10); &#x2F;&#x2F;括号里面是范围，范围在0-9 System.out.println(num); 如果要生成一个1-10之间的随机数: Random ran &#x3D; new Random(); &#x2F;&#x2F;先实例化random对象 int num2 &#x3D; ran.nextInt(10)+1; &#x2F;&#x2F;范围在1-10 System.out.println(num2)","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-08-31T04:43:52.678Z","updated":"2022-08-31T04:43:52.678Z","comments":true,"path":"2022/08/31/hello-world/","link":"","permalink":"http://example.com/2022/08/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"前端基础","slug":"前端基础","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}]}