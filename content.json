{"meta":{"title":"云神","subtitle":"夏木春休","description":"个人博客","author":"yunshen","url":"http://example.com","root":"/"},"pages":[{"title":"photos","date":"2022-08-31T08:34:58.467Z","updated":"2022-08-31T08:34:58.467Z","comments":false,"path":"photos/index.html","permalink":"http://example.com/photos/index.html","excerpt":"","text":""},{"title":"about","date":"2022-08-31T07:40:22.000Z","updated":"2022-08-31T07:46:04.797Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"java07 java泛型","slug":"java07","date":"2022-09-10T08:02:37.000Z","updated":"2022-09-10T08:21:50.467Z","comments":true,"path":"2022/09/10/java07/","link":"","permalink":"http://example.com/2022/09/10/java07/","excerpt":"Java笔记5（泛型） Map实现类：Properites properties类是Hashtable的子类，该对象用于处理属性文件","text":"Java笔记5（泛型） Map实现类：Properites properties类是Hashtable的子类，该对象用于处理属性文件 Map实现类：Properites properties类是Hashtable的子类，该对象用于处理属性文件 由于属性文件里的key、value都是字符串类型，所以Properites里的key和value都是字符串类型 存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法 Iterator接口 Iterator对象称为迭代器，主要用于遍历Collection集合中的元素 所有实现了Collection接口的集合类都有一个iterator()方法，用于返回一个实现了Iterator接口的对象 Iterator仅用于遍历集合，Iterator本身并不提供承装对象的能力，如果需要创建Iterator对象，则必须有一个被迭代的集合 泛型： JDK1.5新加入的，解决数据类型的安全性问题，其中主要原理是在类声明时通过一个标识表示类中某个属性的类型或者某个方法的返回值及参数类型，这样在类声明或实例化时只要指定好需要的具体的类型即可 泛型好处： 1可读性，可以判断集合中的内容类型； 2类型检查，避免插入非法类型； 3获取数据时不在需要强制类型转换； 4类型安全，通过知道使用泛型定义的变量的类型限制，编译器可以更有效地提高Java程序的类型安全； 5提高性能 泛型接口： 泛型接口与泛型类的定义及使用基本相同，泛型接口常被用在各种类的生产器中： 定义一个泛型接口： public interface Generator{ public T next(); } 泛型方法： &#x2F;&#x2F;不借助泛型类来写泛型方法 public class Demo04 { public T goGo(T str) { return str; } public &lt;K,V&gt; K gogo(K str,V aa) { ​ return str; }","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"java06 Java继承","slug":"java06","date":"2022-09-03T15:44:24.000Z","updated":"2022-09-03T15:48:39.593Z","comments":true,"path":"2022/09/03/java06/","link":"","permalink":"http://example.com/2022/09/03/java06/","excerpt":"继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。","text":"继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 继承的作用：通过继承可以快速创建新的类，实现代码的重用，提高程序的可维护性，节省大量创建新类的时间，提高开发效率和开发质量。 子类不能选择性继承父类； Java不支持多重继承，但一个类可以实现多个接口，从而克服单继承的缺点； 构造方法不会被子类继承，但可以从子类中调用父类的构造方法。 继承的优点继承过来的字段和方法，可以像任何其他字段和方法一样被直接使用；在子类中可以声明一个与父类中同名的新字段或静态方法，从而“隐藏”父类中的字段或方法；可以在子类中声明一个在父类中没有的新字段和方法；可以在子类中编写一个父类当中具有相同名的新实例方法，这称为“方法重写”或“方法覆盖”；可以在子类中编写一个调用父类构造方法的子类构造方法，既可以隐式地实现，也可以通过使用关键字super来实现。 package com.yunshen.demo; public class Animal {&#x2F;&#x2F;父类 放动物共有的属性 //属性 private String name; private int age; private int hp; private int sex; //构造方法 public Animal() &#123; // TODO Auto-generated constructor stub System.out.println(&quot;这是Animal的无参构造&quot;); &#125; public Animal(String name, int age, int hp, int sex) &#123; super(); this.name = name; this.age = age; this.hp = hp; this.sex = sex; &#125; //成员方法 public void eat() &#123; System.out.println(&quot;动物吃的方法&quot;); &#125; public void sleep() &#123; System.out.println(&quot;动物睡的方法&quot;); &#125; public void run() &#123; System.out.println(&quot;动物跑的方法&quot;); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getHp() &#123; return hp; &#125; public void setHp(int hp) &#123; this.hp = hp; &#125; public int getSex() &#123; return sex; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125; @Override public String toString() &#123; return &quot;Animal [name=&quot; + name + &quot;, age=&quot; + age + &quot;, hp=&quot; + hp + &quot;, sex=&quot; + sex + &quot;]&quot;; &#125; } package com.yunshen.demo; public class Cat extends Animal{&#x2F;&#x2F;Cat 继承 Animal public Cat () &#123; System.out.println(&quot;Cat的构造方法&quot;); &#125; public void eat() &#123; System.out.println(&quot;猫吃老鼠&quot;); &#125; } package com.yunshen.demo; public class Snake extends Animal { private int sp; public Snake() &#123; // TODO Auto-generated constructor stub &#125; public Snake(String name, int age, int hp, int sex) &#123; // TODO Auto-generated constructor stub &#125; public void px() &#123; System.out.println(&quot;爬行&quot;); &#125; public int getSp() &#123; return sp; &#125; public void setSp(int sp) &#123; this.sp = sp; &#125; } package com.yunshen.demo; public class Test { public static void main(String[] args) &#123; &#x2F;&#x2F; Animal an &#x3D; new Animal();&#x2F;&#x2F; an.setHp(1000);&#x2F;&#x2F; an.eat(); System.out.println(&quot;------Cat-----&quot;); /* * * 构造子类对象的时候，父类的构造方法会被执行 * 如果子类也有父类一样的方法，就会使用子类自己的方法 * */ Cat cat = new Cat(); cat.eat(); cat.setName(&quot;加菲&quot;); System.out.println(cat.getName()); System.out.println(&quot;------Snake----&quot;); /* * * 继承父类的同时，子类对象本身也可以拥有自己的属性和方法 * */ Snake s = new Snake(); s.eat(); s.px();//自己的方法 s.getSp();//自己独有的属性 s.setHp(500); System.out.println(s.getHp()); /* * 总结： * 属性： * 如果父类有，子类没有，那么子类直接继承父类的属性，如果子类有，那么就用自己的属性 * * 方法： * 如果父类有方法，子类没有，那就用父类的方法，如果子类也有这个方法，，那么子类就执行自己的方法 * * 方法的重写： * 子类和父类的方法具有相同的名字、参数、类型及个数还有返回值也相同 * */ &#125; } package com.yunshen.demo; public class Test2 { public static void main(String[] args) &#123; Animal animal = new Animal(); animal.setName(&quot;动物&quot;); Animal an = new Cat(); an.eat(); Cat cat = (Cat) an;//(强制转换)向下转型，父类转成子类 cat.eat(); &#125; }","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"java05 java快速生成无参与有参构造，快速构建get和set","slug":"java05","date":"2022-08-31T14:00:42.000Z","updated":"2022-08-31T14:04:31.876Z","comments":true,"path":"2022/08/31/java05/","link":"","permalink":"http://example.com/2022/08/31/java05/","excerpt":"Tostring的使用： 在需要使用tostring的实体类里面的空白处右键-找到source-找到Generate toString-选择所以属性，点击 Gennerate即可","text":"Tostring的使用： 在需要使用tostring的实体类里面的空白处右键-找到source-找到Generate toString-选择所以属性，点击 Gennerate即可 快速生成无参与有参构造 无参：右键–source–generate constructors form Superclass–点击generated 有参：右键–source–generate constructor using Field–点击generated 一般实体类的属性都是私有化的，提供公有的方法进行访问，方法快速构建如下： 快速构建get和set：空白处–右键–source–generated getter and setter–选择让外部类访问的属性–点击generated","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"java04 java方法/函数封装","slug":"java04","date":"2022-08-31T13:29:21.000Z","updated":"2022-08-31T13:39:54.702Z","comments":true,"path":"2022/08/31/java04/","link":"","permalink":"http://example.com/2022/08/31/java04/","excerpt":"方法&#x2F;函数的封装格式： 概念：方法可以把相对独立的某个功能抽象出来，使之成为程序中的一个独立实体，可以在同一程序或其他程序中多次重复使用 类型：1、无参无返回值","text":"方法&#x2F;函数的封装格式： 概念：方法可以把相对独立的某个功能抽象出来，使之成为程序中的一个独立实体，可以在同一程序或其他程序中多次重复使用 类型：1、无参无返回值 有参无返回值有参有返回无参有返回值 修饰符 返回值 方法名（参数的类型 参数的变量名）{ 方法体 } 修饰符：public 修饰，一般方法都是用public 返回值：可以是基础数据类型或者复合数据类型，如果没有返回值用void表示 如果有 方法体中结束的时候用return返回对应内容 参数：可以有或者没有，如果有，格式为（参数类型 参数的变量名） 使用main调用，main方法对应类里面的方法的时候，只能调用也有static修饰的方法 调用： 在同一个类里面调用方法 gameHllo()等同与 这个类 this.gameHello() 如果调用其他类里面的方法 先实例化这个类 类的变量名.方法名 package com.yunshen.home; public class HomeUtil { //第一题 public void showLove(int item) &#123;//item为形参 for (int i = 0; i &lt; item; i++) &#123; System.out.println(&quot;云神&quot;); &#125; &#125; //第二题 public void ps(String str) &#123;//形参，只有在后面的括号中可以使用,在调用方法的时候，传入的是实参 System.out.println(str); &#125; ​ &#x2F;&#x2F;第三题 public void showIntArr(int [] arr) { System.out.print(“arr中的值”); for (int i &#x3D; 0; i &lt; arr.length; i++) { System.out.print(arr[i] + “ “); } } //第四题 public void showCharArr2(char[][] chr) &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; chr.length; i++) &#123; for (int j = 0; j &lt; chr.length; j++) &#123; System.out.print(chr[i][j] + &quot; &quot;); &#125; System.out.println(); &#125; &#125; ​ ​ ​ &#x2F;&#x2F;第7题 public int findMax(int[] arr) { &#x2F;&#x2F; TODO Auto-generated method stub int max = 0; for (int i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; return max; &#125; ​ &#x2F;&#x2F;第9题 public int[] addNum(int num, int[] arr) { &#x2F;&#x2F; TODO Auto-generated method stub //获取新数组 int [] newArr = new int [arr.length + 1]; for (int i = 0; i &lt; arr.length; i++) &#123; newArr[i] = arr[i];//把旧数组放到新数组 &#125; newArr[newArr.length - 1] = num;//newArr.length - 1是数组的最后一位数 return newArr; &#125; package com.yunshen.home; import java.util.Scanner; &#x2F;* * 在main方法中根据键盘插入一个1-3000之间的数字n，另外写一个方法showLove，传入这个n，循环n次“云神” *&#x2F; public class Home1 { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(&quot;输入一个1-3000之间的数字&quot;); int num = scanner.nextInt(); if (num &gt; 0 &amp;&amp; num &lt;3000) &#123; /* for (int i = 0; i &lt; num; i++) &#123; System.out.println(&quot;云神&quot;); &#125; */ //实例化工具 HomeUtil hu = new HomeUtil(); hu.showLove(num); &#125;else &#123; System.out.println(&quot;输入有误&quot;); &#125; ​ ​ ​ ​ } } package com.yunshen.home; import java.util.Scanner;&#x2F;* * 在main方法中定义一个字符串，另外写一个方法ps，传入这个字符串，此方法专门负责将传入的字符串打印出来 *&#x2F; public class Home2 { public static void main(String[] args) &#123; String str = &quot;我是个字符串&quot;; // 实例化工具 HomeUtil hu = new HomeUtil(); hu.ps(str); &#125; } package com.yunshen.home; &#x2F;* * 在main方法中定义一个数组，写一个方法showInterArr,专门用来遍历int类型的一维数组 *&#x2F; public class Home3 { public static void main(String[] args) { int [] arr = &#123;1,22,333,44,5&#125;; HomeUtil hu = new HomeUtil(); hu.showIntArr(arr); ​ } } package com.yunshen.home; &#x2F;* * 写一个方法showCharArr2,专门用来遍历char类型的二维数组 *&#x2F;public class Home4 {public static void main(String[] args) {char [][] chr = &#123; &#123;&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;&#125;, &#123;&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;&#125;, &#123;&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;&#125;, &#123;&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;&#125;, &#123;&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;&#125; &#125;; HomeUtil hu = new HomeUtil(); hu.showCharArr2(chr); ​ } } package com.yunshen.home;&#x2F;* * 7.在main方法中有一个int类型的一维数组，写一个方法findMax,用于获取数组中的最大值，调用方法之后将返回的最大值赋值给一个变量a，把a打印出来 *&#x2F; public class Home5 { public static void main(String[] args) { int [] arr = &#123;1,-43,23,345,34&#125;; ​ HomeUtil hu &#x3D; new HomeUtil(); int a &#x3D; hu.findMax(arr); System.out.println(a); &#125; } package com.yunshen.home; import java.util.Scanner; &#x2F;* * 9.在main方法中定义一个int类型的一维数组，根据键盘输入一个数字，写一个方法addNum，传入这个数字和数组，把这个 数字加到这个数组的末尾，之后在main方法中调用addNum的方法把返回的数组赋值给原来的数组，并遍历原来的数组 *&#x2F; public class Home9 { public static void main(String[] args) { int [] arr = &#123;1,22,33,44,555,6&#125;; Scanner scanner = new Scanner(System.in); System.out.println(&quot;输入一个数字:&quot;); HomeUtil hu = new HomeUtil(); int num = scanner.nextInt(); arr = hu.addNum(num,arr); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot; &quot;); &#125; } } }","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"java03 求一个数组的最大值","slug":"java03","date":"2022-08-31T13:22:44.000Z","updated":"2022-08-31T13:23:19.040Z","comments":true,"path":"2022/08/31/java03/","link":"","permalink":"http://example.com/2022/08/31/java03/","excerpt":"","text":"package com.yunshen.demo; public class Test2 { public static void main(String[] args) { //静态初始化 int [] array = &#123;1,2,3,4,5,6,7,8,9,10&#125;; ​​ &#x2F;&#x2F;遍历数组​ for (int i &#x3D; 0; i &lt; array.length; i++) {​ System.out.println(array[i] + “ “);​ }​​ &#x2F;&#x2F;求和​ int sum &#x3D; 0;​ for (int i &#x3D; 0; i &lt; array.length; i++) {​ sum &#x3D; array[i] + sum;&#x2F;&#x2F;sum +&#x3D; array[i];​ }​ System.out.println(“和为：” +sum);​ System.out.println(&quot;-----------&quot;); //求数组的最大值 int [] array2 = &#123;-10,-5,2,20,5,100,13,14,10&#125;; int max = array2[0];//假设第一个值是最大的，然后逐一往后比 for (int i = 0; i &lt; array2.length; i++) &#123; if (max &lt; array2[i]) &#123; max = array2[i]; &#125; &#125; System.out.println(max); ​​ } }","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"java02 输出一个九九乘法表","slug":"java02","date":"2022-08-31T13:20:31.000Z","updated":"2022-08-31T13:21:11.490Z","comments":true,"path":"2022/08/31/java02/","link":"","permalink":"http://example.com/2022/08/31/java02/","excerpt":"","text":"package com.yunshen.home; public class Shape1 { public static void main(String[] args) { for (int i = 1; i &lt; 10; i++) &#123; for (int j = 1; j &lt; i+1; j++) &#123; System.out.print(i + &quot;*&quot; +j + &quot;=&quot; + i * j + &quot; &quot;); &#125; System.out.println(&quot; &quot;); &#125; &#125; }","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"java01 random随机数","slug":"java01","date":"2022-08-31T13:17:30.000Z","updated":"2022-08-31T13:19:06.313Z","comments":true,"path":"2022/08/31/java01/","link":"","permalink":"http://example.com/2022/08/31/java01/","excerpt":"","text":"如果要生成一个0-9之间的随机数: Random ran &#x3D; new Random(); &#x2F;&#x2F;先实例化random对象 int num &#x3D; ran.nextInt(10); &#x2F;&#x2F;括号里面是范围，范围在0-9 System.out.println(num); 如果要生成一个1-10之间的随机数: Random ran &#x3D; new Random(); &#x2F;&#x2F;先实例化random对象 int num2 &#x3D; ran.nextInt(10)+1; &#x2F;&#x2F;范围在1-10 System.out.println(num2)","categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-08-31T04:43:52.678Z","updated":"2022-08-31T04:43:52.678Z","comments":true,"path":"2022/08/31/hello-world/","link":"","permalink":"http://example.com/2022/08/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://example.com/tags/java%E5%9F%BA%E7%A1%80/"}]}